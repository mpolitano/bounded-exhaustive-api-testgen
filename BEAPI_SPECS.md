# Analysis of Specifications using `BEAPI` (RQ3 in Section 4.3 of the paper)

In this section, we analize the `repOKs` provided with the benchmarks, with the help of `BEAPI`.

## Finding mismatches between objects generated from the API and objects generated from repOK

First, move to the scripts folder.

```
cd $BE_EXP_SRC/scripts
```

For simplicity, from now on we will refer to the set of inputs generated with `BEAPI` as `APIStrs`, and the set of structures generated by `Korat` as `REPOKStrs`. All the structures included in `APIStrs` that are not included in `REPOKStrs`, and viceversa, may witness a mismatch between the `API` and `repOK`. Notice that, the structures that belong to one set but not the other must be analyzed manually to find out the root of the problem.

To evaluate if the set of structures generated by `BEAPI` (using the API) is included in the set of structures generated by `Korat` (using the repOK) run the following script:

```
./run-inclusion-beapi-in-korat.sh <benchmark> <case study> <beapi scope> <korat scope> 
```

To evaluate if the set of structures generated by  `Korat` is included in the set of structures generated by `BEAPI` run the following script:

```
./run-inclusion-korat-in-beapi.sh <benchmark> <case study> <korat scope> <beapi scope>  
```

In the above scripts, `<benchmark>` is one of `0_korat`, `1_kiasan`, `2_roops`, `3_fajita`; `<case study>` is one of the case studies of `<benchmark>` listed in section [Available case studies](#Available-case-studies)); `<beapi scope>` is the scope used to generate inputs with `BEAPI`; and `<korat scope>` is the scope used by `Korat` to generate inputs from `repOK`.

Objects serialized by `BEAPI` (`APIStrs`) are stored in file:
```
$BE_EXP_SRC/scripts/results-begen-inclusion/<benchmark>/<case study>/beapi/matching/builders/<scope>/beapi-tests/objects.ser
```

Objects serialized by `Korat` (`REPOKStrs`) are stored in:
```
$BE_EXP_SRC/scripts/results-begen-inclusion/<benchmark>/<case study>/korat/<scope>/korat-tests/objects.ser
```

Structures in `APIStrs` not included in `REPOKStrs` are canonicalized and stored in plain text in file:
```
$BE_EXP_SRC/scripts/results-begen-inclusion/<benchmark>/<case study>/beapi/matching/builders/<scope>/structures-not-included-<scope>.txt
```
Conversely, structures in `REPOKStrs` not included in  `APIStrs` are canonicalized and stored in plain text in file:
```
$BE_EXP_SRC/scripts/results-begen-inclusion/<benchmark>/<case study>/korat/<scope>/structures-not-included-<scope>.txt
```

## An example

Let us analyze the `NodeCachingLinkedList` `repOK` from `2_roops` against the API. This analysis is also discussed in Section 2 of the paper. We'll be using a fixed scope of 3 during the whole example. We first want to find out whether `APIStrs` is a subset of `REPOKStrs`, so we run the following command:

```
./run-inclusion-beapi-in-korat.sh 2_roops ncl.NodeCachingLinkedList 3 3
```

At the end of its execution, the script shows a summary of the results in CSV format:

```
************
Report
Project,Class,Technique,Budget,Other Bdgt,Structures,Other Strs,Not Included,Not Incl %
2_roops,ncl.NodeCachingLinkedList,beapi/matching/builders,3,3,18,228,0,0
************
```

where:

- **Project**: the name of the selected benchmark.
- **Class**: the name of the case study.
- **Technique**: `BEAPI (DEFAULT)`, since we are checking that `APIStrs` is a subset of `REPOKStrs`.
- **Budget**: the scope (maximum number of nodes, integers, etc...) used by `BEAPI`to generate `APIStrs`.
- **Other Bdgt**: the scope (maximum number of nodes, integers, etc...) used by `Korat` to generate `REPOKStrs`.
- **Structures**: the number of structures in `APIStrs`.
- **Other Strs**: the number of structures in `REPOKStrs`.
- **Not Included**: the number of structures in `APIStrs` not included  in `REPOKStrs`.
- **Not Incl %**: the percentage of structures in `APIStrs` not included  in `REPOKStrs`.

In this case, all structures in `APIStrs` (18 structures) belong to `REPOKStrs` (228 structures); hence, `REPOKStrs` is a proper superset of `APIStrs`.
 
For the converse, we run:

```
./run-inclusion-korat-in-beapi.sh 2_roops ncl.NodeCachingLinkedList 3 3
```

The results are shown below:

```
************
Report
Project,Class,Technique,Budget,Other Bdgt,Structures,Other Strs,Not Included,Not Incl %
2_roops,ncl.NodeCachingLinkedList,korat,3,3,228,18,210,92.1
************
```

where:

- **Project**: the name of the selected benchmark.
- **Class**: the name of the case study.
- **Technique**: `Korat`, since we are checking that `REPOKStrs` is a subset of `APISet`.
- **Budget**: the scope (maximum number of nodes, integers, etc...) used by `Korat` to generate `REPOKStrs`.
- **Other Bdgt**: the scope (maximum number of nodes, integers, etc...) used by `BEAPI`to generate `APIStrs`.
- **Structures**: the number of structures in `REPOKStrs `
- **Other Strs**: the number of structures in `APIStrs `
- **Not Included**: the number of structures in `REPOKStrs` not included  in `APIStrs `.
- **Not Incl %**: the percentage of structures in `REPOKStrs ` not included  in `APIStrs `.

As can be seen, 210 structures of `REPOKStrs` are not included in `APIStrs`. These 210 structures may be pointing out to a mismatch between `repOK` and the `API`. These structures stored in plain text in a canonical form in file:

```
$BE_EXP_SRC/scripts/results-begen-inclusion/2_roops/ncl.NodeCachingLinkedList/korat/3/structures-not-included-3.txt 
```

Let us analyze some structures in the aforementioned file to find out the root of the problem.

- Witness structure 1:

```
  1 canonicalizer.DummyHeapRoot.theroot = canonicalizer.DummyHeapRoot:0->[ncl.NodeCachingLinkedList:0] ,
  2 ncl.LinkedListNode.next = ncl.LinkedListNode:0->[null] , ncl.LinkedListNode:1->[ncl.LinkedListNode:1] ,
  3 ncl.LinkedListNode.previous = ncl.LinkedListNode:0->[null] , ncl.LinkedListNode:1->[ncl.LinkedListNode:1] ,
  4 ncl.LinkedListNode.serialVersionUID = ncl.LinkedListNode:0->[1] , ncl.LinkedListNode:1->[1] ,
  5 ncl.LinkedListNode.value = ncl.LinkedListNode:0->[0] , ncl.LinkedListNode:1->[null] ,
  6 ncl.NodeCachingLinkedList.DEFAULT_MAXIMUM_CACHE_SIZE = ncl.NodeCachingLinkedList:0->[20] ,
  7 ncl.NodeCachingLinkedList.cacheSize = ncl.NodeCachingLinkedList:0->[1] ,
  8 ncl.NodeCachingLinkedList.firstCachedNode = ncl.NodeCachingLinkedList:0->[ncl.LinkedListNode:0] ,
  9 ncl.NodeCachingLinkedList.header = ncl.NodeCachingLinkedList:0->[ncl.LinkedListNode:1] ,
  11 ncl.NodeCachingLinkedList.maximumCacheSize = ncl.NodeCachingLinkedList:0->[20] ,
  12 ncl.NodeCachingLinkedList.serialVersionUID = ncl.NodeCachingLinkedList:0->[1] ,
  13 ncl.NodeCachingLinkedList.size = ncl.NodeCachingLinkedList:0->[0] ,
```

The canonicalized witness' root is `ncl.NodeCachingLinkedList:0` (line 1). The structure has 2 nodes, named: `ncl.LinkedListNode:0` and `ncl.LinkedListNode:1`. Line 2 shows the values of the `next` field of each node as follows:
- `ncl.LinkedListNode:0->[null]` means that `next` field of `ncl.LinkedListNode:0` points to `null`.
- `ncl.LinkedListNode:1->[ncl.LinkedListNode:1]` means that the `next` field of `ncl.LinkedListNode:1` point to itself.
Line 8 indicates that the `firstCachedNode` field references `ncl.LinkedListNode:0`, and line 5 shows that the value field of this node is `0`. However, inspecting the source code, we know that the values of nodes moved to the cache list are always set to `null`. In other words, the `NodeCachingLinkedList` API does not allow building objects with cache nodes containing non-null values. Thus, this structure points out to a missing constraint in `repOK`.

- Witness structure 2:

```
   1 canonicalizer.DummyHeapRoot.theroot = canonicalizer.DummyHeapRoot:0->[ncl.NodeCachingLinkedList:0] ,
   2 ncl.LinkedListNode.next = ncl.LinkedListNode:0->[ncl.LinkedListNode:0] ,
   3 ncl.LinkedListNode.previous = ncl.LinkedListNode:0->[ncl.LinkedListNode:0] ,
   4 ncl.LinkedListNode.serialVersionUID = ncl.LinkedListNode:0->[1] ,
   5 ncl.LinkedListNode.value = ncl.LinkedListNode:0->[0] ,
   6 ncl.NodeCachingLinkedList.DEFAULT_MAXIMUM_CACHE_SIZE = ncl.NodeCachingLinkedList:0->[20] ,
   7 ncl.NodeCachingLinkedList.cacheSize = ncl.NodeCachingLinkedList:0->[0] ,
   8 ncl.NodeCachingLinkedList.firstCachedNode = ncl.NodeCachingLinkedList:0->[null] ,
   9 ncl.NodeCachingLinkedList.header = ncl.NodeCachingLinkedList:0->[ncl.LinkedListNode:0] ,
  10 ncl.NodeCachingLinkedList.maximumCacheSize = ncl.NodeCachingLinkedList:0->[20] ,
  11 ncl.NodeCachingLinkedList.serialVersionUID = ncl.NodeCachingLinkedList:0->[1] ,
  12 ncl.NodeCachingLinkedList.size = ncl.NodeCachingLinkedList:0->[0] ,
```

In this case, `line 9` indicates that the `header` field of the list points to `ncl.LinkedListNode:0`, and in `line 5` we have that the value of `ncl.LinkedListNode:0` is `0`. Again, inspecting the source code, we know that `header` must be a dummy node whose value must always be `null`. `repOk` also misses this constraint.

**Table 3** in **Section 4.3** of the paper reports errors we've found in `repOK`s following the approach of this section. All `repOK`s (including those reported to have errors in the table) can be found in the source files located at `$BE_EXP_SRC/<benchmark>/src/main/java/<case study>`, for each `<benchmark>` and `<case study>` described in the section below. 

## Available case studies

- `0_korat`
  - `DoublyLinkedList`: korat.examples.doublylinkedlist.DoublyLinkedList (`DDList`)
  - `FibonacciHeap`: korat.examples.fibheap.FibonacciHeap (`FibHeap`)
  -	`BinomialHeap`: korat.examples.binheap.BinomialHeap (`BinHeap`)
  - `SearchTree`:korat.examples.searchtree.SearchTree (`BST`)
  - `SinglyLinkedList`: korat.examples.singlylinkedlist.SinglyLinkedList (`SLList`)
  - `RedBlackTree`: korat.examples.redblacktree.RedBlackTree (`RBT`)
  - `SortedList`: korat.examples.sortedlist.SortedList (`SortedList`) 

- `1_kiasan`
  - `BinarySearchTree`: binarysearchtree.BinarySearchTree (`BST`)
  - `DoubleLinkedList`: doublylinkedlist.DoubleLinkedList (`DDL`)
  - `TreeSet`: redblacktree.TreeSet(`RBT`) UBICAR LOS FUENTES DONDE CORRESPONDE con el nombre correcto
  - `DisjSetsFast`: disjointSet.fast.DisjSetsFast (`DisjSetFast`)
  - `StackLi`: stack.list.StackLi (`StackList`)
  - `BinaryHeap`: binaryheap.BinaryHeap (`BHeap`)
  - `TreeMap`: redblacktree.TreeMap (`TreeMap`)
  - `DisjSet`: disjointSet.orig.DisjSets (`DisjSet`) 

- `2_roops`
  - `AvlTree`: avl.AvlTree (`AVL`)
  - `NodeCachingLinkedList`: ncl.NodeCachingLinkedList (`NCL`)
  - `BinTree`: bintree.BinTree (`BinTree`)
  - `LinkedList`: linkedlist.LinkedList (`LList`)
  - `TreeSet`: rbt.TreeSet (`RBT`)
  - `FibHeap`: fibheap.FibHeap (`FibHeap`)
  - `BinomialHeap`: bheap.BinomialHeap (`BinHeap`)


- `3_fajita`
  - `BinTree`: bintree1.BinTree (`BinTree`)
  - `AvlTree`: avl1.AvlTree (`AVL`)
  - `TreeSet`: rbt.TreeSet (`RBT`)
  - `BinomialHeap`: bheap.BinomialHeap (`BinHeap`)
  - `SinglyLinkedList`: list.SinglyLinkedList (`SLList`) 
  - `DoubleLinkedList`: cdlist.LinkedList (`DLList`)
  - `NodeCachingLinkedList`: cList.NodeCachingLinkedList (`NCL`)


