# Analysis of Specifications using `BEAPI` (RQ3 in Section 4.3 of the paper)

In this section, we analize the `repOKs` provided with the benchmarks, with the help of `BEAPI`.

## Running a single experiment to find mismatching between repOK and the API.


First, move to the scripts folder.


```
cd script
```

To evaluate if the set of structures generated by  `BEAPI` is included in the set of structures generated by `Korat` run the following script:

```
./run-inclusion-beapi-in-korat.sh <benchmark> <case study> <beapi scope> <korat scope> 
```
 
To evaluate if the set of structures generated by  `Korat` is included in the set of structures generated by `BEAPI`, we run the following script:

```
./run-inclusion-korat-in-beapi.sh <benchmark> <case study> <korat scope> <beapi scope>  
```


In these above scripts,  `<benchmark>` is one of `0_korat`, `1_kiasan`, `2_roops`, `3_fajita`; `<case study>` is one of the case studies of `<benchmark>` listed in the subsection below; `<beapi scope>` is the scope used to generate inputs with `BEAPI`; and `<korat scope>` is the scope used by `Korat` to generate inputs from `repOK`.


***For simplicity from now on, we will refer to the set of inputs generated with `BEAPI` as `APISet`, and the set of structures generated by `Korat` as `RepOKSet`.***

All the structures include in `APISet` that are not included in `RepOkSet`, and vice versa, will witness a  mismatching between `repOK` and the `API`. Notice that, this mismatching must be confirm manually.


As an example,  to analize `NodeCachingLinkedList` from `2_roops` benchmark, execute:

```
./run-inclusion-beapi-in-korat.sh 2_roops ncl.NodeCachingLinkedList 3 3
```

At the end of its execution, the script shows a summary of the results in CSV format:


```
************
Report
Project,Class,Technique,Budget,Other Bdgt,Structures,Other Strs,Not Included,Not Incl %
2_roops,ncl.NodeCachingLinkedList,beapi/matching/builders,3,3,18,228,0,0
************
```

where:

- **Project**: the name of the selected benchmark.
- **Class**: the name of the case study.
- **Technique**: `BEAPI (DEFAULT)`, since we are checking that `APISet` is a subset of `REPOKSet`
- **Budget**: the scope (maximum number of nodes, integers, etc...) used for generate `APISet`
- **Other Bdgt**: the scope (maximum number of nodes, integers, etc...) used for generate `REPOKSet`
- **Structures**: the number of structures in `APISet`
- **Other Strs**: the number of structures in `REPOKSet`
- **Not Included**: the number of structures in `APISet` not included  in `REPOKSet`.
- **Not Incl %**: the percentage of structures in `APISet` not included  in `REPOKSet`.


As can be observed from the above report,  all structures generated by `BEAPI` (18) are included in the set of structures generated by `Korat` (228), since, 0 `BEAPI` structures are **Not Included** in `Korat's` generated structures. It is noticeable in this case,  that `RepOKset` is a  proper superset of `APISet`
 
To analize what is happening with the structures belonging to `REPOKSet` that are not included in `APISet`, execute:


```
./run-inclusion-korat-in-beapi.sh 2_roops ncl.NodeCachingLinkedList 3 3
```

At the end of its execution the script shows a summary of the results in CSV format:

```
************
Report
Project,Class,Technique,Budget,Other Bdgt,Structures,Other Strs,Not Included,Not Incl %
2_roops,ncl.NodeCachingLinkedList,korat,3,3,228,18,210,92.1
************
```

where:

- **Project**: the name of the selected benchmark.
- **Class**: the name of the case study.
- **Technique**: `Korat`, since we are checking that `REPOKSet` is a subset of `APISET`
- **Budget**: the scope (maximum number of nodes, integers, etc...) used for generate `REPOKSet `
- **Other Bdgt**: the scope (maximum number of nodes, integers, etc...) used for generate `APISet `
- **Structures**: the number of structures in `REPOKSet `
- **Other Strs**: the number of structures in `APISet `
- **Not Included**: the number of structures in `REPOKSet` not included  in `APISet `.
- **Not Incl %**: the percentage of structures in `REPOKSet ` not included  in `APISet `.



As can be seen, 210 structures of `REPOKSet` are not included in `APISet`. These 210 structures are pointing out a mismatching between `repOK` and the `API`. Even more, all these structures were identified and, stored in plain text in `results-begen-inclusion/2_roops/ncl.NodeCachingLinkedList/korat/3/structures-not-included-3.txt`, for further analysis. 


We will take for the analysis some of these witness structures. As we mentioned these are described in plain text:

- witness structures 1:

```
  1 canonicalizer.DummyHeapRoot.theroot = canonicalizer.DummyHeapRoot:0->[ncl.NodeCachingLinkedList:0] ,
  2 ncl.LinkedListNode.next = ncl.LinkedListNode:0->[null] , ncl.LinkedListNode:1->[ncl.LinkedListNode:1] ,
  3 ncl.LinkedListNode.previous = ncl.LinkedListNode:0->[null] , ncl.LinkedListNode:1->[ncl.LinkedListNode:1] ,
  4 ncl.LinkedListNode.serialVersionUID = ncl.LinkedListNode:0->[1] , ncl.LinkedListNode:1->[1] ,
  5 ncl.LinkedListNode.value = ncl.LinkedListNode:0->[0] , ncl.LinkedListNode:1->[null] ,
  6 ncl.NodeCachingLinkedList.DEFAULT_MAXIMUM_CACHE_SIZE = ncl.NodeCachingLinkedList:0->[20] ,
  7 ncl.NodeCachingLinkedList.cacheSize = ncl.NodeCachingLinkedList:0->[1] ,
  8 ncl.NodeCachingLinkedList.firstCachedNode = ncl.NodeCachingLinkedList:0->[ncl.LinkedListNode:0] ,
  9 ncl.NodeCachingLinkedList.header = ncl.NodeCachingLinkedList:0->[ncl.LinkedListNode:1] ,
  11 ncl.NodeCachingLinkedList.maximumCacheSize = ncl.NodeCachingLinkedList:0->[20] ,
  12 ncl.NodeCachingLinkedList.serialVersionUID = ncl.NodeCachingLinkedList:0->[1] ,
  13 ncl.NodeCachingLinkedList.size = ncl.NodeCachingLinkedList:0->[0] ,
```

The canonized witness `NodeCachingLinkedlist`, named `ncl.NodeCachingLinkedList:0`,  has 2 nodes, named: `ncl.LinkedListNode:0` (we call it `N0` for short)  and `ncl.LinkedListNode:1` (we call it `N1` for short).  


`Line 2` captures values for  `next` field of `ncl.LinkedListNode` as follow:


- `ncl.LinkedListNode:0->[null]` means  that  `next` field of `N0` point to null, that is:  `N0.next = null`
- `ncl.LinkedListNode:1->[ncl.LinkedListNode:1]`  means that `next` field of `N1` point to `N1` node, that is:  `N1.next = N1`

 
For its part, `line 8`, indicates that the value for `firstCachedNode` field is `N0` (it is the only node linked to the **cache list**, since `N0.next = null`). Furthermore, `line 5` shows values for `value` field  of each node: `N0.value = 0` and `N1.value = null`

Inspecting the source code, we know that the values of nodes inserted on the **cache list** can not be other than `null`. In other words, the `NodeCachingLinkedList` API, does not allow building objects with **cache lists** whose nodes contain non-null values. This structure points out a missing constraint on `repOK`.
  

- witness structures 2:


```
   1 canonicalizer.DummyHeapRoot.theroot = canonicalizer.DummyHeapRoot:0->[ncl.NodeCachingLinkedList:0] ,
   2 ncl.LinkedListNode.next = ncl.LinkedListNode:0->[ncl.LinkedListNode:0] ,
   3 ncl.LinkedListNode.previous = ncl.LinkedListNode:0->[ncl.LinkedListNode:0] ,
   4 ncl.LinkedListNode.serialVersionUID = ncl.LinkedListNode:0->[1] ,
   5 ncl.LinkedListNode.value = ncl.LinkedListNode:0->[0] ,
   6 ncl.NodeCachingLinkedList.DEFAULT_MAXIMUM_CACHE_SIZE = ncl.NodeCachingLinkedList:0->[20] ,
   7 ncl.NodeCachingLinkedList.cacheSize = ncl.NodeCachingLinkedList:0->[0] ,
   8 ncl.NodeCachingLinkedList.firstCachedNode = ncl.NodeCachingLinkedList:0->[null] ,
   9 ncl.NodeCachingLinkedList.header = ncl.NodeCachingLinkedList:0->[ncl.LinkedListNode:0] ,
  10 ncl.NodeCachingLinkedList.maximumCacheSize = ncl.NodeCachingLinkedList:0->[20] ,
  11 ncl.NodeCachingLinkedList.serialVersionUID = ncl.NodeCachingLinkedList:0->[1] ,
  12 ncl.NodeCachingLinkedList.size = ncl.NodeCachingLinkedList:0->[0] ,
```


In this case, `line 9` indicates that  `header` field of the  canonized witness `NodeCachingLinkedlist`, is `ncl.LinkedListNode:0` (`N0`). On the other hand, `line 5`, says that  `N0.value = 0`. Again, inspecting the source code, we know that `header` node is a dummy node and its value cannot be other than null, while `repOk` misses this constraint.
  

Notice that **Table 3** of **Section 4.3** of the paper reports errors found in `repOK` that are part of the case studies of each benchmark. In this table the **Error Description** column shows a brief description of the error found in `repOK`, which was manually identified. All `repOK` errors reported on the table previously mentioned, can be found in the corresponding `java` source file located at `<benchmark>/src/main/java/<case study>` for each `<benchmark>` and `<case study>`. In particular, the previously analyzed errors in  `NodeCachingLinkeList` of `2_roops`,  are also shown as a part of motivation example section of the paper.


Note: The serialized objects of both techniques (`BEAPI` and `Korat`) to be able to perform the inclusion are stored in `scripts/results-begen-inclusion/<benchmark>/<case study>/beapi/matching/builders/3/beapi-tests/objects.ser` and `scripts/results-begen-inclusion/<benchmark>/t<case study>/korat/3/korat-tests/objects.ser`.

## Available case studies

- `0_korat`
  - `DoublyLinkedList`: korat.examples.doublylinkedlist.DoublyLinkedList (`DDList`)
  - `FibonacciHeap`: korat.examples.fibheap.FibonacciHeap (`FibHeap`)
  -	`BinomialHeap`: korat.examples.binheap.BinomialHeap (`BinHeap`)
  - `SearchTree`:korat.examples.searchtree.SearchTree (`BST`)
  - `SinglyLinkedList`: korat.examples.singlylinkedlist.SinglyLinkedList (`SLList`)
  - `RedBlackTree`: korat.examples.redblacktree.RedBlackTree (`RBT`)
  - `SortedList`: korat.examples.sortedlist.SortedList (`SortedList`) 

- `1_kiasan`
  - `BinarySearchTree`: binarysearchtree.BinarySearchTree (`BST`)
  - `DoubleLinkedList`: doublylinkedlist.DoubleLinkedList (`DDL`)
  - `TreeSet`: redblacktree.TreeSet(`RBT`) UBICAR LOS FUENTES DONDE CORRESPONDE con el nombre correcto
  - `DisjSetsFast`: disjointSet.fast.DisjSetsFast (`DisjSetFast`)
  - `StackLi`: stack.list.StackLi (`StackList`)
  - `BinaryHeap`: binaryheap.BinaryHeap (`BHeap`)
  - `TreeMap`: redblacktree.TreeMap (`TreeMap`)
  - `DisjSet`: disjointSet.orig.DisjSets (`DisjSet`) 

- `2_roops`

  - `AvlTree`: avl.AvlTree (`AVL`)
  - `NodeCachingLinkedList`: ncl.NodeCachingLinkedList (`NCL`)
  - `BinTree`: bintree.BinTree (`BinTree`)
  - `LinkedList`: linkedlist.LinkedList (`LList`)
  - `TreeSet`: rbt.TreeSet (`RBT`)
  - `FibHeap`: fibheap.FibHeap (`FibHeap`)
  - `BinomialHeap`: bheap.BinomialHeap (`BinHeap`)


- `3_fajita`
  - `BinTree`: bintree1.BinTree (`BinTree`)
  - `AvlTree`: avl1.AvlTree (`AVL`)
  - `TreeSet`: rbt.TreeSet (`RBT`)
  - `BinomialHeap`: bheap.BinomialHeap (`BinHeap`)
  - `SinglyLinkedList`: list.SinglyLinkedList (`SLList`) 
  - `DoubleLinkedList`: cdlist.LinkedList (`DLList`)
  - `NodeCachingLinkedList`: cList.NodeCachingLinkedList (`NCL`)


